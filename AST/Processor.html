<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  Class: AST::Processor
  
    &mdash; Documentation by YARD 0.8.5.2
  
</title>

  <link rel="stylesheet" href="../css/style.css" type="text/css" media="screen" charset="utf-8" />

  <link rel="stylesheet" href="../css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '../';
  framesUrl = "../frames.html#!" + escape(window.location.href);
</script>


  <script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="../_index.html">Index (P)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../AST.html" title="AST (module)">AST</a></span></span>
     &raquo; 
    <span class="title">Processor</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="../method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="../file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><h1>Class: AST::Processor
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName">Object</span>
      
        <ul class="fullTree">
          <li>Object</li>
          
            <li class="next">AST::Processor</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">lib/ast/processor.rb</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>Processor is a class which helps transforming one AST into another.
In a nutshell, the <span class='object_link'><a href="#process-instance_method" title="AST::Processor#process (method)">#process</a></span> method accepts a <span class='object_link'><a href="Node.html" title="AST::Node (class)">Node</a></span> and dispatches
it to a handler corresponding to its type, and returns a (possibly)
updated variant of the node.</p>

<p>Processor has a set of associated design patterns. They are best
explained with a concrete example. Let’s define a simple arithmetic
language and an AST format for it:</p>

<p>Terminals (AST nodes which do not have other AST nodes inside):</p>

<ul>
  <li><code>(integer &lt;int-literal&gt;)</code>,</li>
</ul>

<p>Nonterminals (AST nodes with other nodes as children):</p>

<ul>
  <li><code>(add &lt;node&gt; &lt;node&gt;)</code>,</li>
  <li><code>(multiply &lt;node&gt; &lt;node&gt;)</code>,</li>
  <li><code>(divide &lt;node&gt; &lt;node&gt;)</code>,</li>
  <li><code>(negate &lt;node&gt;)</code>,</li>
  <li><code>(store &lt;node&gt; &lt;string-literal&gt;)</code>: stores value of <code>&lt;node&gt;</code> into a variable named <code>&lt;string-literal&gt;</code>,</li>
  <li><code>(load &lt;string-literal&gt;)</code>: loads value of a variable named <code>&lt;string-literal&gt;</code>,</li>
  <li><code>(each &lt;node&gt; ...): computes each of the </code><node>`s and prints the result.</node></li>
</ul>

<p>All AST nodes have the same Ruby class, and therefore they don’t
know how to traverse themselves. (A solution which dynamically checks the
type of children is possible, but is slow and error-prone.) So, a subclass
of Processor which knows how to traverse the entire tree should be defined.
Such subclass has a handler for each nonterminal node which recursively
processes children nodes:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>ast</span><span class='tstring_end'>&#39;</span></span>

<span class='kw'>class</span> <span class='const'>ArithmeticsProcessor</span> <span class='op'>&lt;</span> <span class='const'>AST</span><span class='op'>::</span><span class='const'>Processor</span>
  <span class='comment'># This method traverses any binary operators such as (add) or (multiply).
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_process_binary_op'>process_binary_op</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='comment'># Children aren&#39;t decomposed automatically; it is suggested to use Ruby
</span>    <span class='comment'># multiple assignment expansion, as it is very convenient here.
</span>    <span class='id identifier rubyid_left_expr'>left_expr</span><span class='comma'>,</span> <span class='id identifier rubyid_right_expr'>right_expr</span> <span class='op'>=</span> <span class='op'>*</span><span class='id identifier rubyid_node'>node</span>

    <span class='comment'># AST::Node#updated won&#39;t change node type if nil is passed as a first
</span>    <span class='comment'># argument, which allows to reuse the same handler for multiple node types
</span>    <span class='comment'># using `alias&#39; (below).
</span>    <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_updated'>updated</span><span class='lparen'>(</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='lbracket'>[</span>
      <span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_left_expr'>left_expr</span><span class='rparen'>)</span><span class='comma'>,</span>
      <span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_right_expr'>right_expr</span><span class='rparen'>)</span>
    <span class='rbracket'>]</span><span class='rparen'>)</span>
  <span class='kw'>end</span>
  <span class='kw'>alias</span> <span class='id identifier rubyid_on_add'>on_add</span>      <span class='id identifier rubyid_process_binary_op'>process_binary_op</span>
  <span class='kw'>alias</span> <span class='id identifier rubyid_on_multiply'>on_multiply</span> <span class='id identifier rubyid_process_binary_op'>process_binary_op</span>
  <span class='kw'>alias</span> <span class='id identifier rubyid_on_divide'>on_divide</span>   <span class='id identifier rubyid_process_binary_op'>process_binary_op</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_negate'>on_negate</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='comment'># It is also possible to use #process_all for more compact code
</span>    <span class='comment'># if every child is a Node.
</span>    <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_updated'>updated</span><span class='lparen'>(</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_process_all'>process_all</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_store'>on_store</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_expr'>expr</span><span class='comma'>,</span> <span class='id identifier rubyid_variable_name'>variable_name</span> <span class='op'>=</span> <span class='op'>*</span><span class='id identifier rubyid_node'>node</span>

    <span class='comment'># Note that variable_name is not a Node and thus isn&#39;t passed to #process.
</span>    <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_updated'>updated</span><span class='lparen'>(</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='lbracket'>[</span>
      <span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_expr'>expr</span><span class='rparen'>)</span><span class='comma'>,</span>
      <span class='id identifier rubyid_variable_name'>variable_name</span>
    <span class='rbracket'>]</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='comment'># (load) is effectively a terminal node, and so it does not need
</span>  <span class='comment'># an explicit handler, as the following is the default behavior.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_on_load'>on_load</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='kw'>nil</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_each'>on_each</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_updated'>updated</span><span class='lparen'>(</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_process_all'>process_all</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span><span class='rparen'>)</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Let’s test our ArithmeticsProcessor:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_include'>include</span> <span class='const'>AST</span><span class='op'>::</span><span class='const'>Sexp</span>
<span class='id identifier rubyid_expr'>expr</span> <span class='op'>=</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:add</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>2</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>2</span><span class='rparen'>)</span><span class='rparen'>)</span>

<span class='id identifier rubyid_p'>p</span> <span class='const'>ArithmeticsProcessor</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_expr'>expr</span><span class='rparen'>)</span> <span class='op'>==</span> <span class='id identifier rubyid_expr'>expr</span> <span class='comment'># =&gt; true
</span></code></pre>

<p>As expected, it does not change anything at all. This isn’t actually
very useful, so let’s now define a Calculator, which will compute the
expression values:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># This Processor folds nonterminal nodes and returns an (integer)
</span><span class='comment'># terminal node.
</span><span class='kw'>class</span> <span class='const'>ArithmeticsCalculator</span> <span class='op'>&lt;</span> <span class='const'>ArithmeticsProcessor</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_compute_op'>compute_op</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='comment'># First, node children are processed and then unpacked to local
</span>    <span class='comment'># variables.
</span>    <span class='id identifier rubyid_nodes'>nodes</span> <span class='op'>=</span> <span class='id identifier rubyid_process_all'>process_all</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_nodes'>nodes</span><span class='period'>.</span><span class='id identifier rubyid_all?'>all?</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_node'>node</span><span class='op'>|</span> <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span> <span class='op'>==</span> <span class='symbol'>:integer</span> <span class='rbrace'>}</span>
      <span class='comment'># If each of those nodes represents a literal, we can fold this
</span>      <span class='comment'># node!
</span>      <span class='id identifier rubyid_values'>values</span> <span class='op'>=</span> <span class='id identifier rubyid_nodes'>nodes</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_node'>node</span><span class='op'>|</span> <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_children'>children</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span> <span class='rbrace'>}</span>
      <span class='const'>AST</span><span class='op'>::</span><span class='const'>Node</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='lbracket'>[</span>
        <span class='kw'>yield</span><span class='lparen'>(</span><span class='id identifier rubyid_values'>values</span><span class='rparen'>)</span>
      <span class='rbracket'>]</span><span class='rparen'>)</span>
    <span class='kw'>else</span>
      <span class='comment'># Otherwise, we can just leave the current node in the tree and
</span>      <span class='comment'># only update it with processed children nodes, which can be
</span>      <span class='comment'># partially folded.
</span>      <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_updated'>updated</span><span class='lparen'>(</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_nodes'>nodes</span><span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_add'>on_add</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_compute_op'>compute_op</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_left'>left</span><span class='comma'>,</span> <span class='id identifier rubyid_right'>right</span><span class='op'>|</span> <span class='id identifier rubyid_left'>left</span> <span class='op'>+</span> <span class='id identifier rubyid_right'>right</span> <span class='rbrace'>}</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_multiply'>on_multiply</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_compute_op'>compute_op</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_left'>left</span><span class='comma'>,</span> <span class='id identifier rubyid_right'>right</span><span class='op'>|</span> <span class='id identifier rubyid_left'>left</span> <span class='op'>*</span> <span class='id identifier rubyid_right'>right</span> <span class='rbrace'>}</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Let’s check:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='const'>ArithmeticsCalculator</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_expr'>expr</span><span class='rparen'>)</span> <span class='comment'># =&gt; (integer 4)
</span></code></pre>

<p>Excellent, the calculator works! Now, a careful reader could notice that
the ArithmeticsCalculator does not know how to divide numbers. What if we
pass an expression with division to it?</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_expr_with_division'>expr_with_division</span> <span class='op'>=</span> \
  <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:add</span><span class='comma'>,</span>
    <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>1</span><span class='rparen'>)</span><span class='comma'>,</span>
    <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:divide</span><span class='comma'>,</span>
      <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:add</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>8</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>4</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='comma'>,</span>
      <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>3</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='rparen'>)</span> <span class='comment'># 1 + (8 + 4) / 3
</span>
<span class='id identifier rubyid_folded_expr_with_division'>folded_expr_with_division</span> <span class='op'>=</span> <span class='const'>ArithmeticsCalculator</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_expr_with_division'>expr_with_division</span><span class='rparen'>)</span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_folded_expr_with_division'>folded_expr_with_division</span>
<span class='comment'># =&gt; (add
</span><span class='comment'>#      (integer 1)
</span><span class='comment'>#      (divide
</span><span class='comment'>#        (integer 12)
</span><span class='comment'>#        (integer 3)))
</span></code></pre>

<p>As you can see, the expression was folded <em>partially</em>: the inner <code>(add)</code> node which
could be computed was folded to <code>(integer 12)</code>, the <code>(divide)</code> node is left as-is
because there is no computing handler for it, and the root <code>(add)</code> node was also left
as it is because some of its children were not literals.</p>

<p>Note that this partial folding is only possible because the <em>data</em> format, i.e.
the format in which the computed values of the nodes are represented, is the same as
the AST itself.</p>

<p>Let’s extend our ArithmeticsCalculator class further.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>ArithmeticsCalculator</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_on_divide'>on_divide</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_compute_op'>compute_op</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_left'>left</span><span class='comma'>,</span> <span class='id identifier rubyid_right'>right</span><span class='op'>|</span> <span class='id identifier rubyid_left'>left</span> <span class='op'>/</span> <span class='id identifier rubyid_right'>right</span> <span class='rbrace'>}</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_negate'>on_negate</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='comment'># Note how #compute_op works regardless of the operator arity.
</span>    <span class='id identifier rubyid_compute_op'>compute_op</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_value'>value</span><span class='op'>|</span> <span class='op'>-</span><span class='id identifier rubyid_value'>value</span> <span class='rbrace'>}</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Now, let’s apply our renewed ArithmeticsCalculator to a partial result of previous
evaluation:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='const'>ArithmeticsCalculator</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_expr_with_division'>expr_with_division</span><span class='rparen'>)</span> <span class='comment'># =&gt; (integer 5)
</span></code></pre>

<p>Five! Excellent. This is also pretty much how CRuby 1.8 executed its programs.</p>

<p>Now, let’s do some automated bug searching. Division by zero is an error, right?
So if we could detect that someone has divided by zero before the program is even
run, that could save some debugging time.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>DivisionByZeroVerifier</span> <span class='op'>&lt;</span> <span class='const'>ArithmeticsProcessor</span>
  <span class='kw'>class</span> <span class='const'>VerificationFailure</span> <span class='op'>&lt;</span> <span class='const'>Exception</span><span class='semicolon'>;</span> <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_divide'>on_divide</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='comment'># You need to process the children to handle nested divisions
</span>    <span class='comment'># such as:
</span>    <span class='comment'># (divide
</span>    <span class='comment'>#   (integer 1)
</span>    <span class='comment'>#   (divide (integer 1) (integer 0))
</span>    <span class='id identifier rubyid_left'>left</span><span class='comma'>,</span> <span class='id identifier rubyid_right'>right</span> <span class='op'>=</span> <span class='id identifier rubyid_process_all'>process_all</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_right'>right</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span> <span class='op'>==</span> <span class='symbol'>:integer</span> <span class='op'>&amp;&amp;</span>
       <span class='id identifier rubyid_right'>right</span><span class='period'>.</span><span class='id identifier rubyid_children'>children</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span> <span class='op'>==</span> <span class='int'>0</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>VerificationFailure</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Ouch! This code divides by zero.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_divides_by_zero?'>divides_by_zero?</span><span class='lparen'>(</span><span class='id identifier rubyid_ast'>ast</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_ast'>ast</span><span class='rparen'>)</span>
    <span class='kw'>false</span>
  <span class='kw'>rescue</span> <span class='const'>VerificationFailure</span>
    <span class='kw'>true</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_nice_expr'>nice_expr</span> <span class='op'>=</span> \
  <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:divide</span><span class='comma'>,</span>
    <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:add</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>10</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>2</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='comma'>,</span>
    <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>4</span><span class='rparen'>)</span><span class='rparen'>)</span>

<span class='id identifier rubyid_p'>p</span> <span class='const'>DivisionByZeroVerifier</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_divides_by_zero?'>divides_by_zero?</span><span class='lparen'>(</span><span class='id identifier rubyid_nice_expr'>nice_expr</span><span class='rparen'>)</span>
<span class='comment'># =&gt; false. Good.
</span>
<span class='id identifier rubyid_bad_expr'>bad_expr</span> <span class='op'>=</span> \
  <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:add</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>10</span><span class='rparen'>)</span><span class='comma'>,</span>
    <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:divide</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>1</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>0</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='rparen'>)</span>

<span class='id identifier rubyid_p'>p</span> <span class='const'>DivisionByZeroVerifier</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_divides_by_zero?'>divides_by_zero?</span><span class='lparen'>(</span><span class='id identifier rubyid_bad_expr'>bad_expr</span><span class='rparen'>)</span>
<span class='comment'># =&gt; true. WHOOPS. DO NOT RUN THIS.
</span></code></pre>

<p>Of course, this won’t detect more complex cases… unless you use some partial
evaluation before! The possibilites are endless. Have fun.</p>


  </div>
</div>
<div class="tags">
  

</div>






  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#handler_missing-instance_method" title="#handler_missing (instance method)">- (AST::Node<sup>?</sup>) <strong>handler_missing</strong>(node) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Default handler.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#process-instance_method" title="#process (instance method)">- (AST::Node<sup>?</sup>) <strong>process</strong>(node) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Dispatches <code>node</code>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#process_all-instance_method" title="#process_all (instance method)">- (Array&lt;AST::Node&gt;) <strong>process_all</strong>(nodes) </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p><span class='object_link'><a href="#process-instance_method" title="AST::Processor#process (method)">#process</a></span>es each node from <code>nodes</code> and returns an array of results.</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="handler_missing-instance_method">
  
    - (<tt><span class='object_link'><a href="Node.html" title="AST::Node (class)">AST::Node</a></span></tt><sup>?</sup>) <strong>handler_missing</strong>(node) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Default handler. Does nothing.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>node</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Node.html" title="AST::Node (class)">AST::Node</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Node.html" title="AST::Node (class)">AST::Node</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


263
264</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/ast/processor.rb', line 263</span>

<span class='kw'>def</span> <span class='id identifier rubyid_handler_missing'>handler_missing</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="process-instance_method">
  
    - (<tt><span class='object_link'><a href="Node.html" title="AST::Node (class)">AST::Node</a></span></tt><sup>?</sup>) <strong>process</strong>(node) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Dispatches <code>node</code>. If a node has type <code>:foo</code>, then a handler named
<code>on_foo</code> is invoked with one argument, the <code>node</code>; if there isn’t
such a handler, <span class='object_link'><a href="#handler_missing-instance_method" title="AST::Processor#handler_missing (method)">#handler_missing</a></span> is invoked with the same argument.</p>

<p>If the handler returns <code>nil</code>, <code>node</code> is returned; otherwise, the return
value of the handler is passed along.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>node</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Node.html" title="AST::Node (class)">AST::Node</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Node.html" title="AST::Node (class)">AST::Node</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/ast/processor.rb', line 231</span>

<span class='kw'>def</span> <span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
  <span class='kw'>return</span> <span class='kw'>if</span> <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span>

  <span class='id identifier rubyid_node'>node</span> <span class='op'>=</span> <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_to_ast'>to_ast</span>

  <span class='comment'># Invoke a specific handler
</span>  <span class='id identifier rubyid_on_handler'>on_handler</span> <span class='op'>=</span> <span class='symbol'>:on_</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>if</span> <span class='id identifier rubyid_respond_to?'>respond_to?</span> <span class='id identifier rubyid_on_handler'>on_handler</span>
    <span class='id identifier rubyid_new_node'>new_node</span> <span class='op'>=</span> <span class='id identifier rubyid_send'>send</span> <span class='id identifier rubyid_on_handler'>on_handler</span><span class='comma'>,</span> <span class='id identifier rubyid_node'>node</span>
  <span class='kw'>else</span>
    <span class='id identifier rubyid_new_node'>new_node</span> <span class='op'>=</span> <span class='id identifier rubyid_handler_missing'>handler_missing</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_node'>node</span> <span class='op'>=</span> <span class='id identifier rubyid_new_node'>new_node</span> <span class='kw'>if</span> <span class='id identifier rubyid_new_node'>new_node</span>

  <span class='id identifier rubyid_node'>node</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="process_all-instance_method">
  
    - (<tt>Array&lt;<span class='object_link'><a href="Node.html" title="AST::Node (class)">AST::Node</a></span>&gt;</tt>) <strong>process_all</strong>(nodes) 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p><span class='object_link'><a href="#process-instance_method" title="AST::Processor#process (method)">#process</a></span>es each node from <code>nodes</code> and returns an array of results.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nodes</span>
      
      
        <span class='type'>(<tt>Array&lt;<span class='object_link'><a href="Node.html" title="AST::Node (class)">AST::Node</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Array&lt;<span class='object_link'><a href="Node.html" title="AST::Node (class)">AST::Node</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


253
254
255
256
257</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/ast/processor.rb', line 253</span>

<span class='kw'>def</span> <span class='id identifier rubyid_process_all'>process_all</span><span class='lparen'>(</span><span class='id identifier rubyid_nodes'>nodes</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_nodes'>nodes</span><span class='period'>.</span><span class='id identifier rubyid_to_a'>to_a</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_node'>node</span><span class='op'>|</span>
    <span class='id identifier rubyid_process'>process</span> <span class='id identifier rubyid_node'>node</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

    <div id="footer">
  Generated on Mon Jun 17 05:20:40 2013 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.5.2 (ruby-2.0.0).
</div>

  </body>
</html>